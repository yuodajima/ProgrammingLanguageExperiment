結果について，以下の考察を示す．

\subsection{課題3について}
逆ポーランド記法について，目的の結果を得られたことを確認した．
今回はスタックにポップとプッシュを繰り返すことで，目的の記法に変換したが，トークンに与えられた優先度の値でデータを取り出していたことを考えるとこれは課題4の問題とほぼ等価なのではないかと考えられる．なぜなら，課題3も課題4も数値が小さい順番でデータにアクセスしている点が等しいからだ．
よって優先度にしたがってヒープを作成すれば，二分木でも逆ポーランド記法変換の実装が可能であると思われる．

\subsection{課題4について}

今回はデータを絶対値を基準に左右の子にに挿入したものと，それを深さ優先で取り出してデータを根から順に格納した木が結果的にできた．

今回の結果から，実際に二分木を直接昇順ソートで挿入することは避けたほうが良いと思われた．
なぜなら，絶対値昇順ソートでの挿入は根を最小の値とし右の枝にしか新たなノードが生まない一直線の木になり，二分木としての探索効率が最悪になってしまうためである．
加えて，前述のようにソートのために一度データを絶対値を基準に左右の子に格納した木を作成しており，それを深さ優先で全データにアクセスすることで絶対値昇順ソートされた木を作成している，この時点で絶対値の昇順にデータの総和を取ることは可能であり，わざわざ2つ目の木を作成する必要がないのである．

データの取り出しの際にかかる計算量は，一直線の木で\(o(\frac{n}{2})\)となり，そうでない木で\(o(\log_2 2n)\)以上\(o(\frac{n}{2})\)以下である．
同じ目的が達成できるならば計算量が少なくまたコード量が少ない手段を取るべきである．








